{"ast":null,"code":"// The Inflector transforms words from singular to plural, class names to table names, modularized class names to ones without,\n// and class names to foreign keys. The default inflections for pluralization, singularization, and uncountable words are kept\n// in inflections.coffee\n//\n// If you discover an incorrect inflection and require it for your application, you'll need\n// to correct it yourself (explained below).\nvar util = require('./util');\n\nvar inflect = module.exports; // Import [inflections](inflections.html) instance\n\ninflect.inflections = require('./inflections'); // Gives easy access to add inflections to this class\n\ninflect.inflect = function (fn) {\n  fn(inflect.inflections);\n}; // By default, _camelize_ converts strings to UpperCamelCase. If the argument to _camelize_\n// is set to _false_ then _camelize_ produces lowerCamelCase.\n//\n// _camelize_ will also convert '/' to '.' which is useful for converting paths to namespaces.\n//\n//     \"bullet_record\".camelize()             // => \"BulletRecord\"\n//     \"bullet_record\".camelize(false)        // => \"bulletRecord\"\n//     \"bullet_record/errors\".camelize()      // => \"BulletRecord.Errors\"\n//     \"bullet_record/errors\".camelize(false) // => \"bulletRecord.Errors\"\n//\n// As a rule of thumb you can think of _camelize_ as the inverse of _underscore_,\n// though there are cases where that does not hold:\n//\n//     \"SSLError\".underscore.camelize // => \"SslError\"\n\n\ninflect.camelize = function (lower_case_and_underscored_word, first_letter_in_uppercase) {\n  var result;\n  if (first_letter_in_uppercase == null) first_letter_in_uppercase = true;\n  result = util.string.gsub(lower_case_and_underscored_word, /\\/(.?)/, function ($) {\n    return \".\" + util.string.upcase($[1]);\n  });\n  result = util.string.gsub(result, /(?:_)(.)/, function ($) {\n    return util.string.upcase($[1]);\n  });\n\n  if (first_letter_in_uppercase) {\n    return util.string.upcase(result);\n  } else {\n    return util.string.downcase(result);\n  }\n}; // Makes an underscored, lowercase form from the expression in the string.\n//\n// Changes '.' to '/' to convert namespaces to paths.\n//\n//     \"BulletRecord\".underscore()         // => \"bullet_record\"\n//     \"BulletRecord.Errors\".underscore()  // => \"bullet_record/errors\"\n//\n// As a rule of thumb you can think of +underscore+ as the inverse of +camelize+,\n// though there are cases where that does not hold:\n//\n//     \"SSLError\".underscore().camelize() // => \"SslError\"\n\n\ninflect.underscore = function (camel_cased_word) {\n  var self;\n  self = util.string.gsub(camel_cased_word, /\\./, '/');\n  self = util.string.gsub(self, /([A-Z]+)([A-Z][a-z])/, \"$1_$2\");\n  self = util.string.gsub(self, /([a-z\\d])([A-Z])/, \"$1_$2\");\n  self = util.string.gsub(self, /-/, '_');\n  return self.toLowerCase();\n}; // Replaces underscores with dashes in the string.\n//\n//     \"puni_puni\".dasherize()   // => \"puni-puni\"\n\n\ninflect.dasherize = function (underscored_word) {\n  return util.string.gsub(underscored_word, /_/, '-');\n}; // Removes the module part from the expression in the string.\n//\n//     \"BulletRecord.String.Inflections\".demodulize() // => \"Inflections\"\n//     \"Inflections\".demodulize()                     // => \"Inflections\"\n\n\ninflect.demodulize = function (class_name_in_module) {\n  return util.string.gsub(class_name_in_module, /^.*\\./, '');\n}; // Creates a foreign key name from a class name.\n// _separate_class_name_and_id_with_underscore_ sets whether\n// the method should put '_' between the name and 'id'.\n//\n//     \"Message\".foreign_key()      // => \"message_id\"\n//     \"Message\".foreign_key(false) // => \"messageid\"\n//     \"Admin::Post\".foreign_key()  // => \"post_id\"\n\n\ninflect.foreign_key = function (class_name, separate_class_name_and_id_with_underscore) {\n  if (separate_class_name_and_id_with_underscore == null) {\n    separate_class_name_and_id_with_underscore = true;\n  }\n\n  return inflect.underscore(inflect.demodulize(class_name)) + (separate_class_name_and_id_with_underscore ? \"_id\" : \"id\");\n}; // Turns a number into an ordinal string used to denote the position in an\n// ordered sequence such as 1st, 2nd, 3rd, 4th.\n//\n//     ordinalize(1)     // => \"1st\"\n//     ordinalize(2)     // => \"2nd\"\n//     ordinalize(1002)  // => \"1002nd\"\n//     ordinalize(1003)  // => \"1003rd\"\n//     ordinalize(-11)   // => \"-11th\"\n//     ordinalize(-1021) // => \"-1021st\"\n\n\ninflect.ordinalize = function (number) {\n  var _ref;\n\n  number = parseInt(number);\n\n  if ((_ref = Math.abs(number) % 100) === 11 || _ref === 12 || _ref === 13) {\n    return \"\" + number + \"th\";\n  } else {\n    switch (Math.abs(number) % 10) {\n      case 1:\n        return \"\" + number + \"st\";\n\n      case 2:\n        return \"\" + number + \"nd\";\n\n      case 3:\n        return \"\" + number + \"rd\";\n\n      default:\n        return \"\" + number + \"th\";\n    }\n  }\n}; // Checks a given word for uncountability\n//\n//     \"money\".uncountability()     // => true\n//     \"my money\".uncountability()  // => true\n\n\ninflect.uncountability = function (word) {\n  return inflect.inflections.uncountables.some(function (ele, ind, arr) {\n    return word.match(new RegExp(\"(\\\\b|_)\" + ele + \"$\", 'i')) != null;\n  });\n}; // Returns the plural form of the word in the string.\n//\n//     \"post\".pluralize()             // => \"posts\"\n//     \"octopus\".pluralize()          // => \"octopi\"\n//     \"sheep\".pluralize()            // => \"sheep\"\n//     \"words\".pluralize()            // => \"words\"\n//     \"CamelOctopus\".pluralize()     // => \"CamelOctopi\"\n\n\ninflect.pluralize = function (word) {\n  var plural, result;\n  result = word;\n\n  if (word === '' || inflect.uncountability(word)) {\n    return result;\n  } else {\n    for (var i = 0; i < inflect.inflections.plurals.length; i++) {\n      plural = inflect.inflections.plurals[i];\n      result = util.string.gsub(result, plural[0], plural[1]);\n      if (word.match(plural[0]) != null) break;\n    }\n\n    return result;\n  }\n}; // The reverse of _pluralize_, returns the singular form of a word in a string.\n//\n//     \"posts\".singularize()            // => \"post\"\n//     \"octopi\".singularize()           // => \"octopus\"\n//     \"sheep\".singularize()            // => \"sheep\"\n//     \"word\".singularize()             // => \"word\"\n//     \"CamelOctopi\".singularize()      // => \"CamelOctopus\"\n\n\ninflect.singularize = function (word) {\n  var result, singular;\n  result = word;\n\n  if (word === '' || inflect.uncountability(word)) {\n    return result;\n  } else {\n    for (var i = 0; i < inflect.inflections.singulars.length; i++) {\n      singular = inflect.inflections.singulars[i];\n      result = util.string.gsub(result, singular[0], singular[1]);\n      if (word.match(singular[0])) break;\n    }\n\n    return result;\n  }\n}; // Capitalizes the first word and turns underscores into spaces and strips a\n// trailing \"_id\", if any. Like _titleize_, this is meant for creating pretty output.\n//\n//     \"employee_salary\".humanize()   // => \"Employee salary\"\n//     \"author_id\".humanize()         // => \"Author\"\n\n\ninflect.humanize = function (lower_case_and_underscored_word) {\n  var human, result;\n  result = lower_case_and_underscored_word;\n\n  for (var i = 0; i < inflect.inflections.humans.length; i++) {\n    human = inflect.inflections.humans[i];\n    result = util.string.gsub(result, human[0], human[1]);\n  }\n\n  result = util.string.gsub(result, /_id$/, \"\");\n  result = util.string.gsub(result, /_/, \" \");\n  return util.string.capitalize(result, true);\n}; // Capitalizes all the words and replaces some characters in the string to create\n// a nicer looking title. _titleize_ is meant for creating pretty output. It is not\n// used in the Bullet internals.\n//\n//\n//     \"man from the boondocks\".titleize()   // => \"Man From The Boondocks\"\n//     \"x-men: the last stand\".titleize()    // => \"X Men: The Last Stand\"\n\n\ninflect.titleize = function (word) {\n  var self;\n  self = inflect.humanize(inflect.underscore(word));\n  return util.string.capitalize(self);\n}; // Create the name of a table like Bullet does for models to table names. This method\n// uses the _pluralize_ method on the last word in the string.\n//\n//     \"RawScaledScorer\".tableize()   // => \"raw_scaled_scorers\"\n//     \"egg_and_ham\".tableize()       // => \"egg_and_hams\"\n//     \"fancyCategory\".tableize()     // => \"fancy_categories\"\n\n\ninflect.tableize = function (class_name) {\n  return inflect.pluralize(inflect.underscore(class_name));\n}; // Create a class name from a plural table name like Bullet does for table names to models.\n// Note that this returns a string and not a Class.\n//\n//     \"egg_and_hams\".classify()   // => \"EggAndHam\"\n//     \"posts\".classify()          // => \"Post\"\n//\n// Singular names are not handled correctly:\n//\n//     \"business\".classify()       // => \"Busines\"\n\n\ninflect.classify = function (table_name) {\n  return inflect.camelize(inflect.singularize(util.string.gsub(table_name, /.*\\./, '')));\n};","map":null,"metadata":{},"sourceType":"script"}