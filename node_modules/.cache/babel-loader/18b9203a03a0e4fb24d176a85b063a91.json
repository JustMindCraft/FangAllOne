{"ast":null,"code":"// A singleton instance of this class is yielded by Inflector.inflections, which can then be used to specify additional\n// inflection rules. Examples:\n//\n//     BulletSupport.Inflector.inflect ($) ->\n//       $.plural /^(ox)$/i, '$1en'\n//       $.singular /^(ox)en/i, '$1'\n//\n//       $.irregular 'octopus', 'octopi'\n//\n//       $.uncountable \"equipment\"\n//\n// New rules are added at the top. So in the example above, the irregular rule for octopus will now be the first of the\n// pluralization and singularization rules that is runs. This guarantees that your rules run before any of the rules that may\n// already have been loaded.\nvar util = require('./util');\n\nvar Inflections = function Inflections() {\n  this.plurals = [];\n  this.singulars = [];\n  this.uncountables = [];\n  this.humans = [];\n\n  require('./defaults')(this);\n\n  return this;\n}; // Specifies a new pluralization rule and its replacement. The rule can either be a string or a regular expression.\n// The replacement should always be a string that may include references to the matched data from the rule.\n\n\nInflections.prototype.plural = function (rule, replacement) {\n  if (typeof rule == 'string') {\n    this.uncountables = util.array.del(this.uncountables, rule);\n  }\n\n  this.uncountables = util.array.del(this.uncountables, replacement);\n  this.plurals.unshift([rule, replacement]);\n}; // Specifies a new singularization rule and its replacement. The rule can either be a string or a regular expression.\n// The replacement should always be a string that may include references to the matched data from the rule.\n\n\nInflections.prototype.singular = function (rule, replacement) {\n  if (typeof rule == 'string') {\n    this.uncountables = util.array.del(this.uncountables, rule);\n  }\n\n  this.uncountables = util.array.del(this.uncountables, replacement);\n  this.singulars.unshift([rule, replacement]);\n}; // Specifies a new irregular that applies to both pluralization and singularization at the same time. This can only be used\n// for strings, not regular expressions. You simply pass the irregular in singular and plural form.\n//\n//     irregular 'octopus', 'octopi'\n//     irregular 'person', 'people'\n\n\nInflections.prototype.irregular = function (singular, plural, fullMatchRequired) {\n  this.uncountables = util.array.del(this.uncountables, singular);\n  this.uncountables = util.array.del(this.uncountables, plural);\n  var prefix = \"\";\n\n  if (fullMatchRequired) {\n    prefix = \"^\";\n  }\n\n  if (singular[0].toUpperCase() == plural[0].toUpperCase()) {\n    this.plural(new RegExp(\"(\" + prefix + singular[0] + \")\" + singular.slice(1) + \"$\", \"i\"), '$1' + plural.slice(1));\n    this.plural(new RegExp(\"(\" + prefix + plural[0] + \")\" + plural.slice(1) + \"$\", \"i\"), '$1' + plural.slice(1));\n    this.singular(new RegExp(\"(\" + prefix + plural[0] + \")\" + plural.slice(1) + \"$\", \"i\"), '$1' + singular.slice(1));\n  } else {\n    this.plural(new RegExp(prefix + singular[0].toUpperCase() + singular.slice(1) + \"$\"), plural[0].toUpperCase() + plural.slice(1));\n    this.plural(new RegExp(prefix + singular[0].toLowerCase() + singular.slice(1) + \"$\"), plural[0].toLowerCase() + plural.slice(1));\n    this.plural(new RegExp(prefix + plural[0].toUpperCase() + plural.slice(1) + \"$\"), plural[0].toUpperCase() + plural.slice(1));\n    this.plural(new RegExp(prefix + plural[0].toLowerCase() + plural.slice(1) + \"$\"), plural[0].toLowerCase() + plural.slice(1));\n    this.singular(new RegExp(prefix + plural[0].toUpperCase() + plural.slice(1) + \"$\"), singular[0].toUpperCase() + singular.slice(1));\n    this.singular(new RegExp(prefix + plural[0].toLowerCase() + plural.slice(1) + \"$\"), singular[0].toLowerCase() + singular.slice(1));\n  }\n}; // Specifies a humanized form of a string by a regular expression rule or by a string mapping.\n// When using a regular expression based replacement, the normal humanize formatting is called after the replacement.\n// When a string is used, the human form should be specified as desired (example: 'The name', not 'the_name')\n//\n//     human /(.*)_cnt$/i, '$1_count'\n//     human \"legacy_col_person_name\", \"Name\"\n\n\nInflections.prototype.human = function (rule, replacement) {\n  this.humans.unshift([rule, replacement]);\n}; // Add uncountable words that shouldn't be attempted inflected.\n//\n//     uncountable \"money\"\n//     uncountable [\"money\", \"information\"]\n\n\nInflections.prototype.uncountable = function (words) {\n  this.uncountables = this.uncountables.concat(words);\n}; // Clears the loaded inflections within a given scope (default is _'all'_).\n// Give the scope as a symbol of the inflection type, the options are: _'plurals'_,\n// _'singulars'_, _'uncountables'_, _'humans'_.\n//\n//     clear 'all'\n//     clear 'plurals'\n\n\nInflections.prototype.clear = function (scope) {\n  if (scope == null) scope = 'all';\n\n  switch (scope) {\n    case 'all':\n      this.plurals = [];\n      this.singulars = [];\n      this.uncountables = [];\n      this.humans = [];\n\n    default:\n      this[scope] = [];\n  }\n}; // Clears the loaded inflections and initializes them to [default](../inflections.html)\n\n\nInflections.prototype.default = function () {\n  this.plurals = [];\n  this.singulars = [];\n  this.uncountables = [];\n  this.humans = [];\n\n  require('./defaults')(this);\n\n  return this;\n};\n\nmodule.exports = new Inflections();","map":null,"metadata":{},"sourceType":"script"}